<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style>
    .container {
        width: 400px;
        height: 400px;
        border: 1px solid black;
        margin: 100px auto;
        position: relative;
    }
    
    .main-svg > path:hover {
        stroke: green;
    }

    .endPoint{
    	width: 20px;
    	height: 20px;
    	background-color: green;
    	position: absolute;
    	transform: translate(-50%,-50%);
    }
    </style>
</head>

<body>
    <div class="container">
        <svg class="main-svg" width="400" height="400">
            <path d="M0 400 C 0,400 400,0 400,0" stroke="blue" fill="none" stroke-width="10" line-cap="round" line-join="round"></path>
        </svg>
    </div>
    <script src="libs/bezier-curve.js"></script>
    <script>
    var oContainer = document.querySelector('.container');
    var oPath = document.querySelector('path');
    var oSvg = document.querySelector('svg');

    var endPoints = [];
    var bezierArr = [];

    var {
    	pow
    } = Math;

    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }

    class Bezier {
        constructor(endPointOne,endPointTwo) {
            this.points = [endPointOne,endPointTwo];

            this.startEnd = endPointOne;
            this.finishEnd = endPointTwo;

            this.controllerOne = endPointOne.rightCtl;
            this.controllerTwo = endPointTwo.leftCtl;
        }

        toString() {
            var {
                points:[
                	left,right
                ]
            } = this;

            return `C ${
            	left.rightCtl.x
            },${
            	left.rightCtl.y
            } ${
            	right.leftCtl.x
            },${
            	right.leftCtl.y
            } ${
            	right.x
            },${
            	right.y
            }`
        }

        calcWithT(t){
        	var {
        	    points:[
        	    	left,right
        	    ]
        	} = this;

        	return {
        		x:this._getCoords(
        			left.x,
        			left.rightCtl.x,
        			right.leftCtl.x,
        			right.x,
    			t),
        		y:this._getCoords(
        			left.y,
        			left.rightCtl.y,
        			right.leftCtl.y,
        			right.y,
        		t)
        	}
        }

        _getCoords(p0,p1,p2,p3,t){

        	// B(t) = P0(1-t)³ + 3P1t(1-t)² + 3P2t²(1-t) + P3t³

        	return (
        		p0*pow(1-t,3) + 
        		p1*3*t*pow(1-t,2) + 
        		p2*3*pow(t,2)*(1-t) + 
        		p3*pow(t,3)
        	)
        }

        getControls(t){
        	return this._getControlPointForT(t);
        }

        _getControlPointForT(t){

        	var {
        		controllerOne,
        		controllerTwo,
        		startEnd,
        		finishEnd
        	} = this;

        	var Q0 = new Point(
        		startEnd.x + t*(controllerOne.x - startEnd.x),
        		startEnd.y + t*(controllerOne.y - startEnd.y)
    		);

        	var Q1 = new Point(
        		controllerOne.x + t*(controllerTwo.x - controllerOne.x),
        		controllerOne.y + t*(controllerTwo.y - controllerOne.y)
    		);

        	var Q2 = new Point(
        		controllerTwo.x + t*(finishEnd.x - controllerTwo.x),
        		controllerTwo.y + t*(finishEnd.y - controllerTwo.y)
    		);

        	var A0 = new Controller(
        		Q0.x + t*(Q1.x - Q0.x),
        		Q0.y + t*(Q1.y - Q0.y)
    		)

        	var A1 = new Controller(
        		Q1.x + t*(Q2.x - Q1.x),
        		Q1.y + t*(Q2.y - Q1.y)
        	)

        	return {
        		left:A0,
        		right:A1
        	}
        }
    }

    class EndPoint extends Point{

    	constructor(x,y,leftCtl,rightCtl) {
    		super(x,y);

    		leftCtl.endPoint = this;
    		rightCtl.endPoint = this;

    		this.leftCtl = leftCtl
    		this.rightCtl = rightCtl

    		this.movable = true;
    	}

    	getDeltaX(){
    		var {
    			x,leftCtl,rightCtl
    		} = this;

    		return {
    			left: x - leftCtl.x,
    			right: rightCtrl - x
    		}
    	}
    }

    class Controller extends Point{
    	constructor(x,y) {
    		super(x,y);
    	}
    }

    function getEndPointByGivenCubicBezierPointsAndTargetX(bezierObj,x){
    	var {
    		controllerOne,
    		controllerTwo,
    		startEnd,
    		finishEnd
    	} = bezierObj;

    	var percentageX = finishEnd.x - startEnd.x;

    	// not sure which one bigger
    	var percentageY = Math.abs(finishEnd.y - startEnd.y);

    	var bezierFunc = bezier(
    		controllerOne.x/percentageX,
    		1 - controllerOne.y/percentageY,
    		controllerTwo.x/percentageX,
    		1 - controllerTwo.y/percentageY
		)

		var requestX = (x - startEnd.x)/percentageX;

		var t = bezierFunc(requestX).t;
		var y = (1-bezierFunc(requestX).y)* 400;

		var point = bezierObj.calcWithT(t);

		var controls = bezierObj.getControls(t);

    	return new EndPoint(
    		x,
    		y,
    		controls.left,
    		controls.right
		);
    }

    var startLeft = new Controller(0,400);
    var startRight = new Controller(0,400);

    var endLeft = new Controller(400,0);
    var endRight = new Controller(400,0);

    var start = new EndPoint(0,400,startLeft,startRight);
    var end = new EndPoint(400,0,endLeft,endRight);

    var totalBezier = new Bezier(start,end);

    oPath.onmousemove = function({clientX}){
    	var x = clientX - oContainer.offsetLeft;
    	var extraEnd = getEndPointByGivenCubicBezierPointsAndTargetX(totalBezier,x);

    	endPoints.push(extraEnd);

    	var oDiv = document.createElement('div');
    		oDiv.classList.add('endPoint')
    		oDiv.setAttribute('tabindex','0');

    		oDiv.style.left = extraEnd.x + 'px';
    		oDiv.style.top = extraEnd.y + 'px';

		oContainer.appendChild(oDiv);
    }
    </script>
</body>

</html>
